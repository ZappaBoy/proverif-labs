% Created 2021-05-12 Wed 11:10
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\hypersetup{hidelinks}
\author{\href{mailto:f.zappone1@studenti.unimol.it}{Albanese Daniele, Marco Russodivito e Federico Zappone}}
\date{2021-05-12 Wed}
\title{Readme}
\hypersetup{
 pdfauthor={\href{mailto:f.zappone1@studenti.unimol.it}{Albanese Daniele, Marco Russodivito e Federico Zappone}},
 pdftitle={Readme},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Esercizio 1}
\label{sec:org1359874}
\subsection{Denning-sacco}
\label{sec:org526c28b}
\subsubsection{File Horn}
\label{sec:orgf4f8e18}
\begin{verbatim}
pred c/1 elimVar,decompData.
nounif c:x.

fun pk/1.
fun encrypt/2.

fun sign/2.

query c:secret[].

reduc
(* Initialization *)

c:c[];
c:pk(sA[]);
c:pk(sB[]);

(* The attacker *)

c:x & c:encrypt(m,pk(x)) -> c:m;
c:x -> c:pk(x);
c:x & c:y -> c:encrypt(x,y);
c:sign(x,y) -> c:x;
c:x & c:y -> c:sign(x,y);

(* The protocol *)
(* A *)

c:pk(x) -> c:encrypt(sign(k[pk(x)], sA[]), pk(x));

(* B *)

c:encrypt(sign(k, sA[]), pk(sB[])) -> c:encrypt(secret[], pk(k)).
\end{verbatim}

\subsubsection{Output}
\label{sec:org866ac15}
\begin{verbatim}
Initial clauses:
Clause 11: c:c[]
Clause 10: c:pk(sA[])
Clause 9: c:pk(sB[])
Clause 8: c:x & c:encrypt(m,pk(x)) -> c:m
Clause 7: c:x -> c:pk(x)
Clause 6: c:x & c:y -> c:encrypt(x,y)
Clause 5: c:sign(x,y) -> c:x
Clause 4: c:x & c:y -> c:sign(x,y)
Clause 3: c:pk(x) -> c:encrypt(sign(k[pk(x)],sA[]),pk(x))
Clause 2: c:encrypt(sign(k_1,sA[]),pk(sB[])) -> c:encrypt(secret[],pk(k_1))
Clause 1: c:new-name[!att = v]
Completing...
goal reachable: c:secret[]

Derivation:
Abbreviations:
k_1 = k[pk(x)]
clause 8 c:secret[]
    clause 5 c:k_1
        duplicate c:sign(k_1,sA[])
    clause 2 c:encrypt(secret[],pk(k_1))
        clause 6 c:encrypt(sign(k_1,sA[]),pk(sB[]))
            clause 8 c:sign(k_1,sA[])
                duplicate c:x
                clause 3 c:encrypt(sign(k_1,sA[]),pk(x))
                    clause 7 c:pk(x)
                        any c:x
            clause 9 c:pk(sB[])
RESULT goal reachable: c:secret[]
\end{verbatim}
\subsection{Denning-sacco corretto}
\label{sec:orgc496478}
\subsubsection{File Horn}
\label{sec:orgf160621}
\begin{verbatim}
pred c/1 elimVar,decompData.
nounif c:x.

fun pk/1.
fun encrypt/2.

fun sign/2.

query c:secret[].

reduc
(* Initialization *)

c:c[];
c:pk(sA[]);
c:pk(sB[]);

(* The attacker *)

c:x & c:encrypt(m,pk(x)) -> c:m;
c:x -> c:pk(x);
c:x & c:y -> c:encrypt(x,y);
c:sign(x,y) -> c:x;
c:x & c:y -> c:sign(x,y);

(* The protocol *)
(* A *)

c:pk(x) -> c:encrypt(sign((pk(sA[]), pk(x), k[pk(x)]), sA[]), pk(x));

(* B *)

c:encrypt(sign((pk(sA[]), pk(sB[]), k), sA[]), pk(sB[])) -> c:encrypt(secret[], pk(k)).
\end{verbatim}
\subsubsection{Output}
\label{sec:orgb95c92c}
\begin{verbatim}
Initial clauses:
Clause 15: c:(v,v_1,v_2) -> c:v_2
Clause 14: c:(v,v_1,v_2) -> c:v_1
Clause 13: c:(v,v_1,v_2) -> c:v
Clause 12: c:v & c:v_1 & c:v_2 -> c:(v,v_1,v_2)
Clause 11: c:c[]
Clause 10: c:pk(sA[])
Clause 9: c:pk(sB[])
Clause 8: c:x & c:encrypt(m,pk(x)) -> c:m
Clause 7: c:x -> c:pk(x)
Clause 6: c:x & c:y -> c:encrypt(x,y)
Clause 5: c:sign(x,y) -> c:x
Clause 4: c:x & c:y -> c:sign(x,y)
Clause 3: c:pk(x) -> c:encrypt(sign((pk(sA[]),pk(x),k[pk(x)]),sA[]),pk(x))
Clause 2: c:encrypt(sign((pk(sA[]),pk(sB[]),k_1),sA[]),pk(sB[])) -> c:encrypt(secret[],pk(k_1))
Clause 1: c:new-name[!att = v]
Completing...
RESULT goal unreachable: c:secret[]
\end{verbatim}
\subsection{Conclusione}
\label{sec:org64be261}
Dall'output delle due istanze si nota sin da subito che solo nel primo caso \emph{proverif} riesce a raggiungere lo stato \emph{secret[]} e quindi rilevare un errore. Ci√≤
\end{document}
