% Created 2021-05-12 Wed 11:34
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\hypersetup{hidelinks}
\author{\href{mailto:f.zappone1@studenti.unimol.it}{Albanese Daniele, Marco Russodivito e Federico Zappone}}
\date{2021-05-12 Wed}
\title{Readme}
\hypersetup{
 pdfauthor={\href{mailto:f.zappone1@studenti.unimol.it}{Albanese Daniele, Marco Russodivito e Federico Zappone}},
 pdftitle={Readme},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.2 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Esercizio 1}
\label{sec:org371d8a6}
\subsection{Denning-sacco}
\label{sec:org361b5f5}
\subsubsection{File Horn}
\label{sec:orgc7aebae}
\begin{verbatim}
pred c/1 elimVar,decompData.
nounif c:x.

fun pk/1.
fun encrypt/2.

fun sign/2.

query c:secret[].

reduc
(* Initialization *)

c:c[];
c:pk(sA[]);
c:pk(sB[]);

(* The attacker *)

c:x & c:encrypt(m,pk(x)) -> c:m;
c:x -> c:pk(x);
c:x & c:y -> c:encrypt(x,y);
c:sign(x,y) -> c:x;
c:x & c:y -> c:sign(x,y);

(* The protocol *)
(* A *)

c:pk(x) -> c:encrypt(sign(k[pk(x)], sA[]), pk(x));

(* B *)

c:encrypt(sign(k, sA[]), pk(sB[])) -> c:encrypt(secret[], pk(k)).
\end{verbatim}

\subsubsection{Output}
\label{sec:org7daf5ef}
\begin{verbatim}
Initial clauses:
Clause 11: c:c[]
Clause 10: c:pk(sA[])
Clause 9: c:pk(sB[])
Clause 8: c:x & c:encrypt(m,pk(x)) -> c:m
Clause 7: c:x -> c:pk(x)
Clause 6: c:x & c:y -> c:encrypt(x,y)
Clause 5: c:sign(x,y) -> c:x
Clause 4: c:x & c:y -> c:sign(x,y)
Clause 3: c:pk(x) -> c:encrypt(sign(k[pk(x)],sA[]),pk(x))
Clause 2: c:encrypt(sign(k_1,sA[]),pk(sB[])) -> c:encrypt(secret[],pk(k_1))
Clause 1: c:new-name[!att = v]
Completing...
goal reachable: c:secret[]

Derivation:
Abbreviations:
k_1 = k[pk(x)]
clause 8 c:secret[]
    clause 5 c:k_1
        duplicate c:sign(k_1,sA[])
    clause 2 c:encrypt(secret[],pk(k_1))
        clause 6 c:encrypt(sign(k_1,sA[]),pk(sB[]))
            clause 8 c:sign(k_1,sA[])
                duplicate c:x
                clause 3 c:encrypt(sign(k_1,sA[]),pk(x))
                    clause 7 c:pk(x)
                        any c:x
            clause 9 c:pk(sB[])
RESULT goal reachable: c:secret[]
\end{verbatim}
\subsection{Denning-sacco corretto}
\label{sec:orgd4e2c4a}
\subsubsection{File Horn}
\label{sec:org86ecd58}
\begin{verbatim}
pred c/1 elimVar,decompData.
nounif c:x.

fun pk/1.
fun encrypt/2.

fun sign/2.

query c:secret[].

reduc
(* Initialization *)

c:c[];
c:pk(sA[]);
c:pk(sB[]);

(* The attacker *)

c:x & c:encrypt(m,pk(x)) -> c:m;
c:x -> c:pk(x);
c:x & c:y -> c:encrypt(x,y);
c:sign(x,y) -> c:x;
c:x & c:y -> c:sign(x,y);

(* The protocol *)
(* A *)

c:pk(x) -> c:encrypt(sign((pk(sA[]), pk(x), k[pk(x)]), sA[]), pk(x));

(* B *)

c:encrypt(sign((pk(sA[]), pk(sB[]), k), sA[]), pk(sB[])) -> c:encrypt(secret[], pk(k)).
\end{verbatim}
\subsubsection{Output}
\label{sec:orga1a464d}
\begin{verbatim}
Initial clauses:
Clause 15: c:(v,v_1,v_2) -> c:v_2
Clause 14: c:(v,v_1,v_2) -> c:v_1
Clause 13: c:(v,v_1,v_2) -> c:v
Clause 12: c:v & c:v_1 & c:v_2 -> c:(v,v_1,v_2)
Clause 11: c:c[]
Clause 10: c:pk(sA[])
Clause 9: c:pk(sB[])
Clause 8: c:x & c:encrypt(m,pk(x)) -> c:m
Clause 7: c:x -> c:pk(x)
Clause 6: c:x & c:y -> c:encrypt(x,y)
Clause 5: c:sign(x,y) -> c:x
Clause 4: c:x & c:y -> c:sign(x,y)
Clause 3: c:pk(x) -> c:encrypt(sign((pk(sA[]),pk(x),k[pk(x)]),sA[]),pk(x))
Clause 2: c:encrypt(sign((pk(sA[]),pk(sB[]),k_1),sA[]),pk(sB[])) -> c:encrypt(secret[],pk(k_1))
Clause 1: c:new-name[!att = v]
Completing...
RESULT goal unreachable: c:secret[]
\end{verbatim}
\subsection{Conclusione}
\label{sec:orgd208fca}
Dall'output delle due istanze si nota sin da subito che solo nel primo caso \emph{proverif} riesce a raggiungere lo stato \emph{secret[]} e quindi rilevare un errore.
Ciò è possibile dato che nella prima istanza si assume che l'attaccante non arrivi mai a conoscenza di una chiave di sessione. Ciò rende infatti il protocollo vulnerabile al \emph{replay attack}, in quanto, se l'attaccante entra in possesso di una chiave di sessione potrà cifrare un nuovo messaggio che sarà accettato dalla vittima.
Nella seconda istanza ciò non accade dato che si aggiunge come ulteriore forma di sicurezza un \emph{nonce} modellato da \textbf{pk(sA[]), pk(x)} nella riga:
\begin{verbatim}
c:pk(x) -> c:encrypt(sign((pk(sA[]), pk(x), k[pk(x)]), sA[]), pk(x));
\end{verbatim}
\end{document}
